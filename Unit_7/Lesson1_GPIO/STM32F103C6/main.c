/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#define RCC_BASE	0x40021000
#define EXTI_BASE 	0x40010400
#define AFIO_BASE 	0x40010000
#define PORTA_BASE 	0x40010800
#define PORTB_BASE 	0x40010C00

#define NVIC_BASE   0xE000E100

#define RCC_APB2ENR *(volatile uint32_t *)(RCC_BASE+0x18)
#define RCC_CFGR	*(volatile uint32_t *)(RCC_BASE + 0x04)


#define EXTI_IMR	*(volatile uint32_t *)(EXTI_BASE + 0x00)
#define EXTI_EMR	*(volatile uint32_t *)(EXTI_BASE + 0x04)
#define EXTI_RTSR	*(volatile uint32_t *)(EXTI_BASE + 0x08)
#define EXTI_PR		*(volatile uint32_t *)(EXTI_BASE + 0x14)


#define NVIC_ISER	*(volatile uint32_t *)(NVIC_BASE + 0x000)
#define EXTI0_IRQ	6

#define AFIO_EXTICR1	*(volatile uint32_t *)(AFIO_BASE + 0x08)

#define GPIOA_CRL	*(volatile uint32_t *)(PORTA_BASE + 0x00)
#define GPIOA_CRH	*(volatile uint32_t *)(PORTA_BASE + 0x04)
#define GPIOA_ODR	*(volatile uint32_t *)(PORTA_BASE + 0x0C)
#define GPIOA_IDR	*(volatile uint32_t *)(PORTA_BASE + 0x08)

#define GPIOB_CRL	*(volatile uint32_t *)(PORTB_BASE + 0x00)
#define GPIOB_CRH	*(volatile uint32_t *)(PORTB_BASE + 0x04)
#define GPIOB_ODR	*(volatile uint32_t *)(PORTB_BASE + 0x0C)


#define wait for(int i = 0 ; i < 1500; i++)
void CLK_init();
void GPIO_Init();

int main(void)
{
	CLK_init() ;
	GPIO_Init ();
	uint8_t LOC_U8Checker = 0 ;
	while(1)
	{

		// Single Pressing --> external PUR
		uint8_t LOC_U8btnState = (((GPIOA_IDR) & (1 << (1))) >> (1)) ;

		if(LOC_U8Checker == 0 && LOC_U8btnState == 0 )
		{
			LOC_U8Checker = 1 ;
			GPIOB_ODR ^= (1<<1);
		}
		else if (LOC_U8btnState == 1 )
		{
			LOC_U8Checker = 0 ;
		}
		// Multi Pressing --> External PDR
		LOC_U8btnState = (((GPIOA_IDR) & (1 << (13))) >> (13)) ;
		if(LOC_U8btnState == 1)
		{
			GPIOB_ODR ^= (1<<13);
		}

		wait;


	}
}
void CLK_init()
{
	// EXTI --> APB2
	// 1- CONFIG CLK SRC INTERNAL 8 MHZ
	RCC_CFGR &= ~(0b11 << 0) ;
	// 2- CONFIG AHB PRESCALER
	RCC_CFGR &= ~(0b1111 << 4) ;
	// 3- CONFIG APB2 CLK
	RCC_CFGR &= ~(0b111 << 11) ;
	// ENABLE CLK TO PERPHERIAL
	// 1- GPIO PORT B ON APB2
	RCC_APB2ENR |= (1<< 3) ;
	// 2- GPIO PORT A ON APB2
	RCC_APB2ENR |= (1<< 2) ;
}



void GPIO_Init()
{

	// PINA1 --> INPUT FLOATING
	GPIOA_CRL &= ~(0b11 << 4 );
	GPIOA_CRL |= (0b01 << 6 );

	// PINA13 --> INPUT FLOATING
	GPIOA_CRH &= ~(0b11 << 20 );
	GPIOA_CRH |= (0b01 << 22 );

	// PINB1 --> OUTPUT 2MHZ
	GPIOB_CRL  |= (0b10 << 4 );
	GPIOB_CRL &= ~(0b11 << 6 );

	//PINB13 --> OUTPUT
	GPIOB_CRH  |= (0b10 << 20 );
	GPIOB_CRH &= ~(0b11 << 22 );

}
