/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */


#include "../STM32F103_DRIVER/01-LIB/01-STD_TYPES/STD_TYPES.h"

#include "../STM32F103_DRIVER/02-MCAL/01-RCC/RCC_interface.h"
#include "../STM32F103_DRIVER/02-MCAL/02-GPIO/GPIO_interface.h"

#include "FreeRTOS.h"
#include "FreeRTOSConfig.h"
#include "task.h"
#include "semphr.h"


#define STACK_SIZE 100


void LED_Control(void* vPTR);
void ButtonStates(void* vPTR);


u8 BTN_currentState, BTN_prevState ;

/*	Task Creation	*/
TaskHandle_t LEDHandler = NULL;
TaskHandle_t ButtonHandler = NULL;

/*	Semaphores	*/
SemaphoreHandle_t	xSemaphore = NULL;

int main(void)
{
	RCC_voidInitSysClocks();



    /* Create the task, storing the handle. */
    xTaskCreate(LED_Control,"Blink Led",  STACK_SIZE, NULL , 2,&LEDHandler );
    xTaskCreate(ButtonStates,"Button",  STACK_SIZE, NULL , 1,&ButtonHandler );

    /*	Create Semaphore		*/
    xSemaphore = xSemaphoreCreateBinary();

    /*			START SCHEDULER		*/
    vTaskStartScheduler();

    /* Loop forever */
	for(;;);
}

void LED_Control(void* vPTR)
{
	RCC_voidEnableClock(RCC_APB2, PORTA);
	GPIO_voidSetPinDirection(PORTA, PIN2, GPIO_OUTPUT_10MHZ_PUSH_PULL);
	while(1)
	{
		// Try Take Semaphore
		if(xSemaphoreTake(xSemaphore , (TickType_t)5) == pdTRUE)
		{
			GPIO_voidSetPinValue(PORTA,PIN2,BTN_currentState);
		}
		vTaskDelay(50);
	}

}
void ButtonStates(void* vPTR)
{
	RCC_voidEnableClock(RCC_APB2, PORTA);
	GPIO_voidSetPinDirection(PORTA, PIN0, GPIO_INPUT_FLOATING);
	while(1)
	{
		BTN_currentState =  GPIO_u8GetPinValue(PORTA,PIN0);
		// Give Semaphore when state changes
		if(BTN_currentState != BTN_prevState)
		{
			// Give Semaphore
			xSemaphoreGive(xSemaphore);
		}
		BTN_prevState = BTN_currentState ;

		vTaskDelay(25);
	}
}
